"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pvtsutils";
exports.ids = ["vendor-chunks/pvtsutils"];
exports.modules = {

/***/ "(rsc)/./node_modules/pvtsutils/build/index.js":
/*!***********************************************!*\
  !*** ./node_modules/pvtsutils/build/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * MIT License\n * \n * Copyright (c) 2017-2022 Peculiar Ventures, LLC\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n * \n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst ARRAY_BUFFER_NAME = \"[object ArrayBuffer]\";\nclass BufferSourceConverter {\n    static isArrayBuffer(data) {\n        return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;\n    }\n    static toArrayBuffer(data) {\n        if (this.isArrayBuffer(data)) {\n            return data;\n        }\n        if (data.byteLength === data.buffer.byteLength) {\n            return data.buffer;\n        }\n        return this.toUint8Array(data).slice().buffer;\n    }\n    static toUint8Array(data) {\n        return this.toView(data, Uint8Array);\n    }\n    static toView(data, type) {\n        if (data.constructor === type) {\n            return data;\n        }\n        if (this.isArrayBuffer(data)) {\n            return new type(data);\n        }\n        if (this.isArrayBufferView(data)) {\n            return new type(data.buffer, data.byteOffset, data.byteLength);\n        }\n        throw new TypeError(\"The provided value is not of type '(ArrayBuffer or ArrayBufferView)'\");\n    }\n    static isBufferSource(data) {\n        return this.isArrayBufferView(data) || this.isArrayBuffer(data);\n    }\n    static isArrayBufferView(data) {\n        return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);\n    }\n    static isEqual(a, b) {\n        const aView = BufferSourceConverter.toUint8Array(a);\n        const bView = BufferSourceConverter.toUint8Array(b);\n        if (aView.length !== bView.byteLength) {\n            return false;\n        }\n        for(let i = 0; i < aView.length; i++){\n            if (aView[i] !== bView[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static concat(...args) {\n        if (Array.isArray(args[0])) {\n            const buffers = args[0];\n            let size = 0;\n            for (const buffer of buffers){\n                size += buffer.byteLength;\n            }\n            const res = new Uint8Array(size);\n            let offset = 0;\n            for (const buffer of buffers){\n                const view = this.toUint8Array(buffer);\n                res.set(view, offset);\n                offset += view.length;\n            }\n            if (args[1]) {\n                return this.toView(res, args[1]);\n            }\n            return res.buffer;\n        } else {\n            return this.concat(args);\n        }\n    }\n}\nclass Utf8Converter {\n    static fromString(text) {\n        const s = unescape(encodeURIComponent(text));\n        const uintArray = new Uint8Array(s.length);\n        for(let i = 0; i < s.length; i++){\n            uintArray[i] = s.charCodeAt(i);\n        }\n        return uintArray.buffer;\n    }\n    static toString(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let encodedString = \"\";\n        for(let i = 0; i < buf.length; i++){\n            encodedString += String.fromCharCode(buf[i]);\n        }\n        const decodedString = decodeURIComponent(escape(encodedString));\n        return decodedString;\n    }\n}\nclass Utf16Converter {\n    static toString(buffer, littleEndian = false) {\n        const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);\n        const dataView = new DataView(arrayBuffer);\n        let res = \"\";\n        for(let i = 0; i < arrayBuffer.byteLength; i += 2){\n            const code = dataView.getUint16(i, littleEndian);\n            res += String.fromCharCode(code);\n        }\n        return res;\n    }\n    static fromString(text, littleEndian = false) {\n        const res = new ArrayBuffer(text.length * 2);\n        const dataView = new DataView(res);\n        for(let i = 0; i < text.length; i++){\n            dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);\n        }\n        return res;\n    }\n}\nclass Convert {\n    static isHex(data) {\n        return typeof data === \"string\" && /^[a-z0-9]+$/i.test(data);\n    }\n    static isBase64(data) {\n        return typeof data === \"string\" && /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(data);\n    }\n    static isBase64Url(data) {\n        return typeof data === \"string\" && /^[a-zA-Z0-9-_]+$/i.test(data);\n    }\n    static ToString(buffer, enc = \"utf8\") {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        switch(enc.toLowerCase()){\n            case \"utf8\":\n                return this.ToUtf8String(buf);\n            case \"binary\":\n                return this.ToBinary(buf);\n            case \"hex\":\n                return this.ToHex(buf);\n            case \"base64\":\n                return this.ToBase64(buf);\n            case \"base64url\":\n                return this.ToBase64Url(buf);\n            case \"utf16le\":\n                return Utf16Converter.toString(buf, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buf);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static FromString(str, enc = \"utf8\") {\n        if (!str) {\n            return new ArrayBuffer(0);\n        }\n        switch(enc.toLowerCase()){\n            case \"utf8\":\n                return this.FromUtf8String(str);\n            case \"binary\":\n                return this.FromBinary(str);\n            case \"hex\":\n                return this.FromHex(str);\n            case \"base64\":\n                return this.FromBase64(str);\n            case \"base64url\":\n                return this.FromBase64Url(str);\n            case \"utf16le\":\n                return Utf16Converter.fromString(str, true);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(str);\n            default:\n                throw new Error(`Unknown type of encoding '${enc}'`);\n        }\n    }\n    static ToBase64(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        if (typeof btoa !== \"undefined\") {\n            const binary = this.ToString(buf, \"binary\");\n            return btoa(binary);\n        } else {\n            return Buffer.from(buf).toString(\"base64\");\n        }\n    }\n    static FromBase64(base64) {\n        const formatted = this.formatString(base64);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64(formatted)) {\n            throw new TypeError(\"Argument 'base64Text' is not Base64 encoded\");\n        }\n        if (typeof atob !== \"undefined\") {\n            return this.FromBinary(atob(formatted));\n        } else {\n            return new Uint8Array(Buffer.from(formatted, \"base64\")).buffer;\n        }\n    }\n    static FromBase64Url(base64url) {\n        const formatted = this.formatString(base64url);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isBase64Url(formatted)) {\n            throw new TypeError(\"Argument 'base64url' is not Base64Url encoded\");\n        }\n        return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\")));\n    }\n    static ToBase64Url(data) {\n        return this.ToBase64(data).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=/g, \"\");\n    }\n    static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch(encoding){\n            case \"ascii\":\n                return this.FromBinary(text);\n            case \"utf8\":\n                return Utf8Converter.fromString(text);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.fromString(text);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.fromString(text, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n        switch(encoding){\n            case \"ascii\":\n                return this.ToBinary(buffer);\n            case \"utf8\":\n                return Utf8Converter.toString(buffer);\n            case \"utf16\":\n            case \"utf16be\":\n                return Utf16Converter.toString(buffer);\n            case \"utf16le\":\n            case \"usc2\":\n                return Utf16Converter.toString(buffer, true);\n            default:\n                throw new Error(`Unknown type of encoding '${encoding}'`);\n        }\n    }\n    static FromBinary(text) {\n        const stringLength = text.length;\n        const resultView = new Uint8Array(stringLength);\n        for(let i = 0; i < stringLength; i++){\n            resultView[i] = text.charCodeAt(i);\n        }\n        return resultView.buffer;\n    }\n    static ToBinary(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        let res = \"\";\n        for(let i = 0; i < buf.length; i++){\n            res += String.fromCharCode(buf[i]);\n        }\n        return res;\n    }\n    static ToHex(buffer) {\n        const buf = BufferSourceConverter.toUint8Array(buffer);\n        const splitter = \"\";\n        const res = [];\n        const len = buf.length;\n        for(let i = 0; i < len; i++){\n            const char = buf[i].toString(16).padStart(2, \"0\");\n            res.push(char);\n        }\n        return res.join(splitter);\n    }\n    static FromHex(hexString) {\n        let formatted = this.formatString(hexString);\n        if (!formatted) {\n            return new ArrayBuffer(0);\n        }\n        if (!Convert.isHex(formatted)) {\n            throw new TypeError(\"Argument 'hexString' is not HEX encoded\");\n        }\n        if (formatted.length % 2) {\n            formatted = `0${formatted}`;\n        }\n        const res = new Uint8Array(formatted.length / 2);\n        for(let i = 0; i < formatted.length; i = i + 2){\n            const c = formatted.slice(i, i + 2);\n            res[i / 2] = parseInt(c, 16);\n        }\n        return res.buffer;\n    }\n    static ToUtf16String(buffer, littleEndian = false) {\n        return Utf16Converter.toString(buffer, littleEndian);\n    }\n    static FromUtf16String(text, littleEndian = false) {\n        return Utf16Converter.fromString(text, littleEndian);\n    }\n    static Base64Padding(base64) {\n        const padCount = 4 - base64.length % 4;\n        if (padCount < 4) {\n            for(let i = 0; i < padCount; i++){\n                base64 += \"=\";\n            }\n        }\n        return base64;\n    }\n    static formatString(data) {\n        return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, \"\")) || \"\";\n    }\n}\nConvert.DEFAULT_UTF8_ENCODING = \"utf8\";\nfunction assign(target, ...sources) {\n    const res = arguments[0];\n    for(let i = 1; i < arguments.length; i++){\n        const obj = arguments[i];\n        for(const prop in obj){\n            res[prop] = obj[prop];\n        }\n    }\n    return res;\n}\nfunction combine(...buf) {\n    const totalByteLength = buf.map((item)=>item.byteLength).reduce((prev, cur)=>prev + cur);\n    const res = new Uint8Array(totalByteLength);\n    let currentPos = 0;\n    buf.map((item)=>new Uint8Array(item)).forEach((arr)=>{\n        for (const item2 of arr){\n            res[currentPos++] = item2;\n        }\n    });\n    return res.buffer;\n}\nfunction isEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for(let i = 0; i < bytes1.byteLength; i++){\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.BufferSourceConverter = BufferSourceConverter;\nexports.Convert = Convert;\nexports.assign = assign;\nexports.combine = combine;\nexports.isEqual = isEqual;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcHZ0c3V0aWxzL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVCQyxHQUVEO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQztJQUNGLE9BQU9DLGNBQWNDLElBQUksRUFBRTtRQUN2QixPQUFPUCxPQUFPUSxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDSCxVQUFVSDtJQUNwRDtJQUNBLE9BQU9PLGNBQWNKLElBQUksRUFBRTtRQUN2QixJQUFJLElBQUksQ0FBQ0QsYUFBYSxDQUFDQyxPQUFPO1lBQzFCLE9BQU9BO1FBQ1g7UUFDQSxJQUFJQSxLQUFLSyxVQUFVLEtBQUtMLEtBQUtNLE1BQU0sQ0FBQ0QsVUFBVSxFQUFFO1lBQzVDLE9BQU9MLEtBQUtNLE1BQU07UUFDdEI7UUFDQSxPQUFPLElBQUksQ0FBQ0MsWUFBWSxDQUFDUCxNQUFNUSxLQUFLLEdBQUdGLE1BQU07SUFDakQ7SUFDQSxPQUFPQyxhQUFhUCxJQUFJLEVBQUU7UUFDdEIsT0FBTyxJQUFJLENBQUNTLE1BQU0sQ0FBQ1QsTUFBTVU7SUFDN0I7SUFDQSxPQUFPRCxPQUFPVCxJQUFJLEVBQUVXLElBQUksRUFBRTtRQUN0QixJQUFJWCxLQUFLWSxXQUFXLEtBQUtELE1BQU07WUFDM0IsT0FBT1g7UUFDWDtRQUNBLElBQUksSUFBSSxDQUFDRCxhQUFhLENBQUNDLE9BQU87WUFDMUIsT0FBTyxJQUFJVyxLQUFLWDtRQUNwQjtRQUNBLElBQUksSUFBSSxDQUFDYSxpQkFBaUIsQ0FBQ2IsT0FBTztZQUM5QixPQUFPLElBQUlXLEtBQUtYLEtBQUtNLE1BQU0sRUFBRU4sS0FBS2MsVUFBVSxFQUFFZCxLQUFLSyxVQUFVO1FBQ2pFO1FBQ0EsTUFBTSxJQUFJVSxVQUFVO0lBQ3hCO0lBQ0EsT0FBT0MsZUFBZWhCLElBQUksRUFBRTtR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QVNBLEtBQUsvRyxVQUFVLEVBQUVnSCxNQUFNLENBQUMsQ0FBQ0MsTUFBTUMsTUFBUUQsT0FBT0M7SUFDeEYsTUFBTXZGLE1BQU0sSUFBSXRCLFdBQVd3RztJQUMzQixJQUFJTSxhQUFhO0lBQ2pCNUUsSUFBSXVFLEdBQUcsQ0FBQyxDQUFDQyxPQUFTLElBQUkxRyxXQUFXMEcsT0FBT0ssT0FBTyxDQUFDLENBQUNDO1FBQzdDLEtBQUssTUFBTUMsU0FBU0QsSUFBSztZQUNyQjFGLEdBQUcsQ0FBQ3dGLGFBQWEsR0FBR0c7UUFDeEI7SUFDSjtJQUNBLE9BQU8zRixJQUFJMUIsTUFBTTtBQUNyQjtBQUNBLFNBQVNhLFFBQVF5RyxNQUFNLEVBQUVDLE1BQU07SUFDM0IsSUFBSSxDQUFFRCxDQUFBQSxVQUFVQyxNQUFLLEdBQUk7UUFDckIsT0FBTztJQUNYO0lBQ0EsSUFBSUQsT0FBT3ZILFVBQVUsS0FBS3dILE9BQU94SCxVQUFVLEVBQUU7UUFDekMsT0FBTztJQUNYO0lBQ0EsTUFBTXlILEtBQUssSUFBSXBILFdBQVdrSDtJQUMxQixNQUFNRyxLQUFLLElBQUlySCxXQUFXbUg7SUFDMUIsSUFBSyxJQUFJcEcsSUFBSSxHQUFHQSxJQUFJbUcsT0FBT3ZILFVBQVUsRUFBRW9CLElBQUs7UUFDeEMsSUFBSXFHLEVBQUUsQ0FBQ3JHLEVBQUUsS0FBS3NHLEVBQUUsQ0FBQ3RHLEVBQUUsRUFBRTtZQUNqQixPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUVBOUIsNkJBQTZCLEdBQUdHO0FBQ2hDSCxlQUFlLEdBQUdnRTtBQUNsQmhFLGNBQWMsR0FBR2dIO0FBQ2pCaEgsZUFBZSxHQUFHc0g7QUFDbEJ0SCxlQUFlLEdBQUd3QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQxMy1haS1zYWFzLy4vbm9kZV9tb2R1bGVzL3B2dHN1dGlscy9idWlsZC9pbmRleC5qcz8yYWJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTUlUIExpY2Vuc2VcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMjIgUGVjdWxpYXIgVmVudHVyZXMsIExMQ1xuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNvbnN0IEFSUkFZX0JVRkZFUl9OQU1FID0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiO1xyXG5jbGFzcyBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIge1xyXG4gICAgc3RhdGljIGlzQXJyYXlCdWZmZXIoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgPT09IEFSUkFZX0JVRkZFUl9OQU1FO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRvQXJyYXlCdWZmZXIoZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXlCdWZmZXIoZGF0YSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPT09IGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50b1VpbnQ4QXJyYXkoZGF0YSkuc2xpY2UoKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdG9VaW50OEFycmF5KGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1ZpZXcoZGF0YSwgVWludDhBcnJheSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdG9WaWV3KGRhdGEsIHR5cGUpIHtcclxuICAgICAgICBpZiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gdHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgdHlwZShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNCdWZmZXJTb3VyY2UoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpXHJcbiAgICAgICAgICAgIHx8IHRoaXMuaXNBcnJheUJ1ZmZlcihkYXRhKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc0FycmF5QnVmZmVyVmlldyhkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKVxyXG4gICAgICAgICAgICB8fCAoZGF0YSAmJiB0aGlzLmlzQXJyYXlCdWZmZXIoZGF0YS5idWZmZXIpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc0VxdWFsKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBhVmlldyA9IEJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYSk7XHJcbiAgICAgICAgY29uc3QgYlZpZXcgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGIpO1xyXG4gICAgICAgIGlmIChhVmlldy5sZW5ndGggIT09IGJWaWV3LmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFWaWV3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhVmlld1tpXSAhPT0gYlZpZXdbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb25jYXQoLi4uYXJncykge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICBsZXQgc2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcclxuICAgICAgICAgICAgICAgIHNpemUgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XHJcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy50b1VpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIHJlcy5zZXQodmlldywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSB2aWV3Lmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJnc1sxXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9WaWV3KHJlcywgYXJnc1sxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlcy5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQoYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIFV0ZjhDb252ZXJ0ZXIge1xyXG4gICAgc3RhdGljIGZyb21TdHJpbmcodGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHMgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodGV4dCkpO1xyXG4gICAgICAgIGNvbnN0IHVpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KHMubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdWludEFycmF5W2ldID0gcy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdWludEFycmF5LmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyB0b1N0cmluZyhidWZmZXIpIHtcclxuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgbGV0IGVuY29kZWRTdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWNvZGVkU3RyaW5nID0gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlbmNvZGVkU3RyaW5nKSk7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZWRTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgVXRmMTZDb252ZXJ0ZXIge1xyXG4gICAgc3RhdGljIHRvU3RyaW5nKGJ1ZmZlciwgbGl0dGxlRW5kaWFuID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IEJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgIGxldCByZXMgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBkYXRhVmlldy5nZXRVaW50MTYoaSwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVN0cmluZyh0ZXh0LCBsaXR0bGVFbmRpYW4gPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBBcnJheUJ1ZmZlcih0ZXh0Lmxlbmd0aCAqIDIpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHJlcyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihpICogMiwgdGV4dC5jaGFyQ29kZUF0KGkpLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbnZlcnQge1xyXG4gICAgc3RhdGljIGlzSGV4KGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgJiYgL15bYS16MC05XSskL2kudGVzdChkYXRhKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc0Jhc2U2NChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiXHJcbiAgICAgICAgICAgICYmIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KGRhdGEpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzQmFzZTY0VXJsKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgJiYgL15bYS16QS1aMC05LV9dKyQvaS50ZXN0KGRhdGEpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIFRvU3RyaW5nKGJ1ZmZlciwgZW5jID0gXCJ1dGY4XCIpIHtcclxuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgc3dpdGNoIChlbmMudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVG9VdGY4U3RyaW5nKGJ1Zik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRvQmluYXJ5KGJ1Zik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJoZXhcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRvSGV4KGJ1Zik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRvQmFzZTY0KGJ1Zik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlNjR1cmxcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRvQmFzZTY0VXJsKGJ1Zik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRmMTZDb252ZXJ0ZXIudG9TdHJpbmcoYnVmLCB0cnVlKTtcclxuICAgICAgICAgICAgY2FzZSBcInV0ZjE2XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmJlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRmMTZDb252ZXJ0ZXIudG9TdHJpbmcoYnVmKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlIG9mIGVuY29kaW5nICcke2VuY30nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIEZyb21TdHJpbmcoc3RyLCBlbmMgPSBcInV0ZjhcIikge1xyXG4gICAgICAgIGlmICghc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoZW5jLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcInV0ZjhcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkZyb21VdGY4U3RyaW5nKHN0cik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkZyb21CaW5hcnkoc3RyKTtcclxuICAgICAgICAgICAgY2FzZSBcImhleFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRnJvbUhleChzdHIpO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Gcm9tQmFzZTY0KHN0cik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlNjR1cmxcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkZyb21CYXNlNjRVcmwoc3RyKTtcclxuICAgICAgICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci5mcm9tU3RyaW5nKHN0ciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwidXRmMTZiZVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLmZyb21TdHJpbmcoc3RyKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlIG9mIGVuY29kaW5nICcke2VuY30nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIFRvQmFzZTY0KGJ1ZmZlcikge1xyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBpZiAodHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gdGhpcy5Ub1N0cmluZyhidWYsIFwiYmluYXJ5XCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYnRvYShiaW5hcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1ZikudG9TdHJpbmcoXCJiYXNlNjRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIEZyb21CYXNlNjQoYmFzZTY0KSB7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRTdHJpbmcoYmFzZTY0KTtcclxuICAgICAgICBpZiAoIWZvcm1hdHRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUNvbnZlcnQuaXNCYXNlNjQoZm9ybWF0dGVkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgJ2Jhc2U2NFRleHQnIGlzIG5vdCBCYXNlNjQgZW5jb2RlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhdG9iICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkZyb21CaW5hcnkoYXRvYihmb3JtYXR0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShmb3JtYXR0ZWQsIFwiYmFzZTY0XCIpKS5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIEZyb21CYXNlNjRVcmwoYmFzZTY0dXJsKSB7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRTdHJpbmcoYmFzZTY0dXJsKTtcclxuICAgICAgICBpZiAoIWZvcm1hdHRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUNvbnZlcnQuaXNCYXNlNjRVcmwoZm9ybWF0dGVkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgJ2Jhc2U2NHVybCcgaXMgbm90IEJhc2U2NFVybCBlbmNvZGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5Gcm9tQmFzZTY0KHRoaXMuQmFzZTY0UGFkZGluZyhmb3JtYXR0ZWQucmVwbGFjZSgvXFwtL2csIFwiK1wiKS5yZXBsYWNlKC9cXF8vZywgXCIvXCIpKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgVG9CYXNlNjRVcmwoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLlRvQmFzZTY0KGRhdGEpLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC9cXD0vZywgXCJcIik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgRnJvbVV0ZjhTdHJpbmcodGV4dCwgZW5jb2RpbmcgPSBDb252ZXJ0LkRFRkFVTFRfVVRGOF9FTkNPRElORykge1xyXG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgY2FzZSBcImFzY2lpXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Gcm9tQmluYXJ5KHRleHQpO1xyXG4gICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0ZjhDb252ZXJ0ZXIuZnJvbVN0cmluZyh0ZXh0KTtcclxuICAgICAgICAgICAgY2FzZSBcInV0ZjE2XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1dGYxNmJlXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRmMTZDb252ZXJ0ZXIuZnJvbVN0cmluZyh0ZXh0KTtcclxuICAgICAgICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcclxuICAgICAgICAgICAgY2FzZSBcInVzYzJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci5mcm9tU3RyaW5nKHRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGUgb2YgZW5jb2RpbmcgJyR7ZW5jb2Rpbmd9J2ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBUb1V0ZjhTdHJpbmcoYnVmZmVyLCBlbmNvZGluZyA9IENvbnZlcnQuREVGQVVMVF9VVEY4X0VOQ09ESU5HKSB7XHJcbiAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xyXG4gICAgICAgICAgICBjYXNlIFwiYXNjaWlcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlRvQmluYXJ5KGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRmOENvbnZlcnRlci50b1N0cmluZyhidWZmZXIpO1xyXG4gICAgICAgICAgICBjYXNlIFwidXRmMTZcIjpcclxuICAgICAgICAgICAgY2FzZSBcInV0ZjE2YmVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci50b1N0cmluZyhidWZmZXIpO1xyXG4gICAgICAgICAgICBjYXNlIFwidXRmMTZsZVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwidXNjMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLnRvU3RyaW5nKGJ1ZmZlciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdHlwZSBvZiBlbmNvZGluZyAnJHtlbmNvZGluZ30nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIEZyb21CaW5hcnkodGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHN0cmluZ0xlbmd0aCA9IHRleHQubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdFZpZXcgPSBuZXcgVWludDhBcnJheShzdHJpbmdMZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0Vmlld1tpXSA9IHRleHQuY2hhckNvZGVBdChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdFZpZXcuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIFRvQmluYXJ5KGJ1ZmZlcikge1xyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBsZXQgcmVzID0gXCJcIjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIFRvSGV4KGJ1ZmZlcikge1xyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICBjb25zdCBzcGxpdHRlciA9IFwiXCI7XHJcbiAgICAgICAgY29uc3QgcmVzID0gW107XHJcbiAgICAgICAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBidWZbaV0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcclxuICAgICAgICAgICAgcmVzLnB1c2goY2hhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXMuam9pbihzcGxpdHRlcik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgRnJvbUhleChoZXhTdHJpbmcpIHtcclxuICAgICAgICBsZXQgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRTdHJpbmcoaGV4U3RyaW5nKTtcclxuICAgICAgICBpZiAoIWZvcm1hdHRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUNvbnZlcnQuaXNIZXgoZm9ybWF0dGVkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgJ2hleFN0cmluZycgaXMgbm90IEhFWCBlbmNvZGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9ybWF0dGVkLmxlbmd0aCAlIDIpIHtcclxuICAgICAgICAgICAgZm9ybWF0dGVkID0gYDAke2Zvcm1hdHRlZH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShmb3JtYXR0ZWQubGVuZ3RoIC8gMik7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXR0ZWQubGVuZ3RoOyBpID0gaSArIDIpIHtcclxuICAgICAgICAgICAgY29uc3QgYyA9IGZvcm1hdHRlZC5zbGljZShpLCBpICsgMik7XHJcbiAgICAgICAgICAgIHJlc1tpIC8gMl0gPSBwYXJzZUludChjLCAxNik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXMuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIFRvVXRmMTZTdHJpbmcoYnVmZmVyLCBsaXR0bGVFbmRpYW4gPSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBVdGYxNkNvbnZlcnRlci50b1N0cmluZyhidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgRnJvbVV0ZjE2U3RyaW5nKHRleHQsIGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIFV0ZjE2Q29udmVydGVyLmZyb21TdHJpbmcodGV4dCwgbGl0dGxlRW5kaWFuKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBCYXNlNjRQYWRkaW5nKGJhc2U2NCkge1xyXG4gICAgICAgIGNvbnN0IHBhZENvdW50ID0gNCAtIChiYXNlNjQubGVuZ3RoICUgNCk7XHJcbiAgICAgICAgaWYgKHBhZENvdW50IDwgNCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGJhc2U2NCArPSBcIj1cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmFzZTY0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZvcm1hdFN0cmluZyhkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEucmVwbGFjZSgvW1xcblxcclxcdCBdL2csIFwiXCIpKSB8fCBcIlwiO1xyXG4gICAgfVxyXG59XHJcbkNvbnZlcnQuREVGQVVMVF9VVEY4X0VOQ09ESU5HID0gXCJ1dGY4XCI7XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIC4uLnNvdXJjZXMpIHtcclxuICAgIGNvbnN0IHJlcyA9IGFyZ3VtZW50c1swXTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgcmVzW3Byb3BdID0gb2JqW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gY29tYmluZSguLi5idWYpIHtcclxuICAgIGNvbnN0IHRvdGFsQnl0ZUxlbmd0aCA9IGJ1Zi5tYXAoKGl0ZW0pID0+IGl0ZW0uYnl0ZUxlbmd0aCkucmVkdWNlKChwcmV2LCBjdXIpID0+IHByZXYgKyBjdXIpO1xyXG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlTGVuZ3RoKTtcclxuICAgIGxldCBjdXJyZW50UG9zID0gMDtcclxuICAgIGJ1Zi5tYXAoKGl0ZW0pID0+IG5ldyBVaW50OEFycmF5KGl0ZW0pKS5mb3JFYWNoKChhcnIpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0yIG9mIGFycikge1xyXG4gICAgICAgICAgICByZXNbY3VycmVudFBvcysrXSA9IGl0ZW0yO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcy5idWZmZXI7XHJcbn1cclxuZnVuY3Rpb24gaXNFcXVhbChieXRlczEsIGJ5dGVzMikge1xyXG4gICAgaWYgKCEoYnl0ZXMxICYmIGJ5dGVzMikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoYnl0ZXMxLmJ5dGVMZW5ndGggIT09IGJ5dGVzMi5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYjEgPSBuZXcgVWludDhBcnJheShieXRlczEpO1xyXG4gICAgY29uc3QgYjIgPSBuZXcgVWludDhBcnJheShieXRlczIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlczEuYnl0ZUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuZXhwb3J0cy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIgPSBCdWZmZXJTb3VyY2VDb252ZXJ0ZXI7XG5leHBvcnRzLkNvbnZlcnQgPSBDb252ZXJ0O1xuZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG5leHBvcnRzLmNvbWJpbmUgPSBjb21iaW5lO1xuZXhwb3J0cy5pc0VxdWFsID0gaXNFcXVhbDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFSUkFZX0JVRkZFUl9OQU1FIiwiQnVmZmVyU291cmNlQ29udmVydGVyIiwiaXNBcnJheUJ1ZmZlciIsImRhdGEiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJ0b0FycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImJ1ZmZlciIsInRvVWludDhBcnJheSIsInNsaWNlIiwidG9WaWV3IiwiVWludDhBcnJheSIsInR5cGUiLCJjb25zdHJ1Y3RvciIsImlzQXJyYXlCdWZmZXJWaWV3IiwiYnl0ZU9mZnNldCIsIlR5cGVFcnJvciIsImlzQnVmZmVyU291cmNlIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJpc0VxdWFsIiwiYSIsImIiLCJhVmlldyIsImJWaWV3IiwibGVuZ3RoIiwiaSIsImNvbmNhdCIsImFyZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJidWZmZXJzIiwic2l6ZSIsInJlcyIsIm9mZnNldCIsInZpZXciLCJzZXQiLCJVdGY4Q29udmVydGVyIiwiZnJvbVN0cmluZyIsInRleHQiLCJzIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ1aW50QXJyYXkiLCJjaGFyQ29kZUF0IiwiYnVmIiwiZW5jb2RlZFN0cmluZyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImRlY29kZWRTdHJpbmciLCJkZWNvZGVVUklDb21wb25lbnQiLCJlc2NhcGUiLCJVdGYxNkNvbnZlcnRlciIsImxpdHRsZUVuZGlhbiIsImFycmF5QnVmZmVyIiwiZGF0YVZpZXciLCJEYXRhVmlldyIsImNvZGUiLCJnZXRVaW50MTYiLCJzZXRVaW50MTYiLCJDb252ZXJ0IiwiaXNIZXgiLCJ0ZXN0IiwiaXNCYXNlNjQiLCJpc0Jhc2U2NFVybCIsIlRvU3RyaW5nIiwiZW5jIiwidG9Mb3dlckNhc2UiLCJUb1V0ZjhTdHJpbmciLCJUb0JpbmFyeSIsIlRvSGV4IiwiVG9CYXNlNjQiLCJUb0Jhc2U2NFVybCIsIkVycm9yIiwiRnJvbVN0cmluZyIsInN0ciIsIkZyb21VdGY4U3RyaW5nIiwiRnJvbUJpbmFyeSIsIkZyb21IZXgiLCJGcm9tQmFzZTY0IiwiRnJvbUJhc2U2NFVybCIsImJ0b2EiLCJiaW5hcnkiLCJCdWZmZXIiLCJmcm9tIiwiYmFzZTY0IiwiZm9ybWF0dGVkIiwiZm9ybWF0U3RyaW5nIiwiYXRvYiIsImJhc2U2NHVybCIsIkJhc2U2NFBhZGRpbmciLCJyZXBsYWNlIiwiZW5jb2RpbmciLCJERUZBVUxUX1VURjhfRU5DT0RJTkciLCJzdHJpbmdMZW5ndGgiLCJyZXN1bHRWaWV3Iiwic3BsaXR0ZXIiLCJsZW4iLCJjaGFyIiwicGFkU3RhcnQiLCJwdXNoIiwiam9pbiIsImhleFN0cmluZyIsImMiLCJwYXJzZUludCIsIlRvVXRmMTZTdHJpbmciLCJGcm9tVXRmMTZTdHJpbmciLCJwYWRDb3VudCIsImFzc2lnbiIsInRhcmdldCIsInNvdXJjZXMiLCJhcmd1bWVudHMiLCJvYmoiLCJwcm9wIiwiY29tYmluZSIsInRvdGFsQnl0ZUxlbmd0aCIsIm1hcCIsIml0ZW0iLCJyZWR1Y2UiLCJwcmV2IiwiY3VyIiwiY3VycmVudFBvcyIsImZvckVhY2giLCJhcnIiLCJpdGVtMiIsImJ5dGVzMSIsImJ5dGVzMiIsImIxIiwiYjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pvtsutils/build/index.js\n");

/***/ })

};
;